<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Submarine Message Log</title>
        <script type="text/javascript">
            // Request permission for browser notifications on page load
            document.addEventListener('DOMContentLoaded', function () {
                if (!("Notification" in window)) {
                    alert("This browser does not support desktop notification");
                }
                else if (Notification.permission !== 'denied') {
                    Notification.requestPermission();
                }
            });
        </script>
    </head>
    <body>
        <h1>Autonomous Pool Submarine</h1>
        <p>Connection: <span id="status" style="font-weight: bold;">N/A</span></p>
        <!-- Start/Stop Button -->
        <button id="startStopButton" style="background-color: green; font-size: 24px; padding: 10px 20px;">Start</button>

        <p><code>/web_message</code> messages received: <button onclick="clearMessages()">Clear Messages</button>
        <ul id="messages" style="font-weight: bold;"></ul></p>
    
        <!-- Include ROSLIB and Event Emitter -->
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/roslib@1/build/roslib.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/easeljs@1/lib/easeljs.js"></script>
        <script type="text/javascript" src=https://cdn.jsdelivr.net/npm/eventemitter2@6/lib/eventemitter2.js></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/ros2d@0/build/ros2d.js"></script>


        <script type="text/javascript">
            // Create ros object to communicate over your Rosbridge connection
            const ros = new ROSLIB.Ros({ url: "ws://localhost:9090" });
            //const ros = new ROSLIB.Ros({ url: "ws://192.168.86.127:9090" });

            // When the Rosbridge server connects, fill the span with id "status" with "successful"
            ros.on("connection", () => {    
                document.getElementById("status").innerHTML = "successful";
            });

            // When the Rosbridge server experiences an error, fill the "status" span with the returned error
            ros.on("error", (error) => {
                document.getElementById("status").innerHTML = `errored out (${error})`;
		// Wait for 30 seconds before resetting and publishing
    		setTimeout(resetButtonAndPublish, 30000);
            });

            // When the Rosbridge server shuts down, fill the "status" span with "closed"
            ros.on("close", () => {
                document.getElementById("status").innerHTML = "closed";
                // Wait for 30 seconds before resetting and publishing
    		setTimeout(resetButtonAndPublish, 30000);
            });

            // Function to load messages from local storage and display them
            function loadMessages() {
                const messages = JSON.parse(localStorage.getItem('receivedMessages')) || [];
                const ul = document.getElementById("messages");
                messages.forEach((message) => {
                    const li = document.createElement("li");
                    li.appendChild(document.createTextNode(message));
                    ul.appendChild(li);
                });
            }

            // Create a listener for /web_message
            const my_topic_listener = new ROSLIB.Topic({
                ros,
                name: "/web_message",
                messageType: "std_msgs/String",
            });

            // Function to display a browser notification
            function displayNotification(message) {
                if (Notification.permission === "granted") {
                    var notification = new Notification("New Message", {
                        body: message,
                        icon: 'path_to_icon' // optional
                    });
                }
            }

            // When we receive a message on /web_message, add its data as a list item to the "messages" ul
            my_topic_listener.subscribe((message) => {
                const ul = document.getElementById("messages");
                const newMessage = document.createElement("li");
                newMessage.appendChild(document.createTextNode(message.data));
                ul.appendChild(newMessage);

                // Save the updated list of messages to local storage
                const existingMessages = JSON.parse(localStorage.getItem('receivedMessages')) || [];
                existingMessages.push(message.data);
                localStorage.setItem('receivedMessages', JSON.stringify(existingMessages));

                // Display the notification
                displayNotification(message.data);
            });
            
            //Button to clear message log
            function clearMessages() {
            	// Clear local storage
            	localStorage.removeItem('receivedMessages');

            	// Clear messages from the display
            	const ul = document.getElementById("messages");
            	while (ul.firstChild) {
                    ul.removeChild(ul.firstChild);
            	}
            }
  
            <!-- Start/Stop Button -->
            // Define the start/stop button
            const button = document.getElementById('startStopButton');

            // Retrieve the saved state from localStorage or default to false
            let isStarted = localStorage.getItem('isStarted') === 'true';

            // Update button appearance based on the retrieved state
            if (isStarted) {
                button.style.backgroundColor = 'red';
                button.textContent = 'Stop';
            } else {
                button.style.backgroundColor = 'green';
                button.textContent = 'Start';
            }

            // Define the ROS topic
            const startTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/start',
                messageType: 'std_msgs/Int32'
            });

            // Function to publish a message to the /start topic
            function publishMessage(message) {
                const msg = new ROSLIB.Message({
                data: message
                });
                startTopic.publish(msg);
            }
          

            // Event listener for the button
            button.addEventListener('click', () => {
                // Try to publish the message and handle errors
                try {
                    if (!isStarted) {
                        // Publish 1 to start
                        publishMessage(1);
                        button.style.backgroundColor = 'red';
                        button.textContent = 'Stop';
                    } else {
                        // Publish 0 to stop
                        publishMessage(0);
                        button.style.backgroundColor = 'green';
                        button.textContent = 'Start';
                    }
                    // Toggle the state
                    isStarted = !isStarted;

                    // Save the new state to localStorage
                    localStorage.setItem('isStarted', isStarted);
                } catch (error) {
                    console.error('Error publishing message:', error);
                    // Change button to yellow and show warning
                    button.style.backgroundColor = 'yellow';
                    button.textContent = 'Warning';
                    // Publish -1 to indicate an error
                    publishMessage(-1);
                }
            });
            
            // Function to reset the button to 'Start' and publish 0 to the /start topic
            function resetButtonAndPublish() {
                // Reset the button appearance
                button.style.backgroundColor = 'green';
                button.textContent = 'Start';

                // Publish 0 to indicate 'stopped'
                publishMessage(0);

                // Update the isStarted state
                isStarted = false;

                // Save the new state to localStorage
                localStorage.setItem('isStarted', isStarted);
            }
            
            // Set an interval to continuously publish the value every 1/4 second (250 milliseconds)
            setInterval(() => {
                publishMessage(isStarted ? 1 : 0);
            }, 250);
            
            // Function to check the connection status
    	    function checkConnection() {
            	if (document.getElementById("status").innerHTML !== "successful") {
            	    // If not successful, refresh the page
            	    location.reload();
            	} else {
             	    // If successful, clear the interval
            	    clearInterval(refreshInterval);
            	}
    	    }

    	    // Set an interval to check the connection status every 5 seconds
    	    var refreshInterval = setInterval(checkConnection, 5000);
    
    	    window.addEventListener('load', loadMessages);
	    window.addEventListener('load', function() {
    	    	publishMessage(isStarted ? 1 : 0);
	    });

        </script>
    </body>
</html>

